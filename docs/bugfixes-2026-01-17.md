# Bug Fixes - 2026-01-17

本文件記錄了 2026-01-17 進行的 bug 修復，涵蓋後端 API、前端元件及時區處理等多個面向。

---

## 目錄

1. [Cursor 分頁邏輯錯誤導致重複記錄](#1-cursor-分頁邏輯錯誤導致重複記錄)
2. [預算進度條 NaN 防護](#2-預算進度條-nan-防護)
3. [預算為 0 被誤判為未設定](#3-預算為-0-被誤判為未設定)
4. [日期計算使用伺服器時區而非用戶時區](#4-日期計算使用伺服器時區而非用戶時區)
5. [BudgetProgressBar optional chaining 清理](#5-budgetprogressbar-optional-chaining-清理)
6. [時間排序使用字串比較而非 datetime 比較](#6-時間排序使用字串比較而非-datetime-比較)
7. [Cursor timezone-aware vs naive datetime 比較錯誤](#7-cursor-timezone-aware-vs-naive-datetime-比較錯誤)
8. [get_daily_trend 使用伺服器時區](#8-get_daily_trend-使用伺服器時區)
9. [Dashboard endpoint 缺少錯誤處理](#9-dashboard-endpoint-缺少錯誤處理)
10. [toLocaleDateString 不支援時間格式化](#10-tolocaledatestring-不支援時間格式化)
11. [多月份日期範圍計算使用固定 30 天](#11-多月份日期範圍計算使用固定-30-天)
12. [日期範圍計算取得 8 天而非 7 天](#12-日期範圍計算取得-8-天而非-7-天)
13. [get_recent_records 使用伺服器時區](#13-get_recent_records-使用伺服器時區)
14. [查詢歷史分頁載入重複顯示](#14-查詢歷史分頁載入重複顯示)
15. [Cursor 分頁同秒記錄被跳過](#15-cursor-分頁同秒記錄被跳過)

---

## 1. Cursor 分頁邏輯錯誤導致重複記錄

**檔案**: `backend/app/database/crud.py:514-516`

**問題**:
- 取了 `limit + 1` 筆記錄來判斷是否有下一頁
- 截斷為 `limit` 筆後，用截斷後的 `records[-1]` 作為 cursor
- 導致下一頁查詢 `created_at < cursor` 會重複包含上一頁的最後一筆

**修復**:
```python
# 修復前
if len(records) > limit:
    records = records[:limit]
    next_cursor = records[-1].created_at  # 錯誤

# 修復後
if len(records) > limit:
    next_cursor = records[limit].created_at  # 先取第 limit+1 筆
    records = records[:limit]  # 再截斷
```

---

## 2. 預算進度條 NaN 防護

**檔案**: `frontend/src/components/dashboard/BudgetProgressBar.tsx:156`

**問題**:
- `budget.remaining !== null` 檢查無法攔截 `NaN`
- 當 `remaining` 為 `NaN` 時會顯示錯誤的金額

**修復**:
```tsx
// 修復前
{budget.remaining !== null && (

// 修復後
{budget.remaining !== null && !Number.isNaN(budget.remaining) && (
```

---

## 3. 預算為 0 被誤判為未設定

**檔案**: 
- `frontend/src/components/dashboard/BudgetProgressBar.tsx:55-56`
- `backend/app/api/accounting.py:413-428`

**問題**:
- 前端 `!budget?.monthly_limit` 將 `0` 視為 falsy
- 後端 `if monthly_limit` 同樣將 `0` 視為 falsy
- 預算為 0 代表「不允許任何支出」，應顯示進度條

**修復**:

前端:
```tsx
// 修復前
if (!budget?.monthly_limit || isEditing) {

// 修復後
if (budget?.monthly_limit == null || isEditing) {
```

後端:
```python
# 使用 "is not None" 區分「未設定」和「設為 0」
has_budget = monthly_limit is not None

# 處理除以 0 的情況
percentage = (
    round(stats.total / monthly_limit * 100, 1)
    if has_budget and monthly_limit > 0
    else (100.0 if has_budget and stats.total > 0 else 0.0 if has_budget else None)
)
```

---

## 4. 日期計算使用伺服器時區而非用戶時區

**檔案**: `backend/app/api/accounting.py:237-238`

**問題**:
- `datetime.now()` 返回伺服器本地時間（通常是 UTC）
- 當伺服器在 UTC，用戶在 UTC+8 時，日期可能差一天

**修復**:
```python
from zoneinfo import ZoneInfo

# 取得用戶時區的當前時間
try:
    tz = ZoneInfo(user_timezone)
except Exception:
    tz = ZoneInfo("Asia/Taipei")
now_in_user_tz = datetime.now(tz)

# 使用 now_in_user_tz 計算日期範圍
today = now_in_user_tz.strftime("%Y-%m-%d")
week_ago = (now_in_user_tz - timedelta(days=6)).strftime("%Y-%m-%d")
```

---

## 5. BudgetProgressBar optional chaining 清理

**檔案**: `frontend/src/components/dashboard/BudgetProgressBar.tsx:131, 144`

**問題**:
- 早期返回已保證 `monthly_limit` 不為 null
- 但程式碼仍使用 optional chaining，可能造成混淆

**修復**:
```tsx
// 修復前
setBudgetInput(budget.monthly_limit?.toString() ?? '');
/ ${budget.monthly_limit?.toLocaleString()}

// 修復後
setBudgetInput(String(budget.monthly_limit ?? ''));
/ ${budget.monthly_limit.toLocaleString()}
```

---

## 6. 時間排序使用字串比較而非 datetime 比較

**檔案**: `backend/app/services/user_sheets_service.py:640-649`

**問題**:
- 依賴字串格式是字典序可排序的假設是脆弱的
- 如果時間格式不一致，字串排序會失敗

**修復**:
```python
# 修復前
all_records.sort(key=lambda x: x.get("時間", ""), reverse=True)

# 修復後
def parse_time_for_sort(record: Dict) -> datetime:
    time_str = record.get("時間", "")
    try:
        return datetime.strptime(time_str, "%Y-%m-%d %H:%M")
    except (ValueError, TypeError):
        return datetime.min

all_records.sort(key=parse_time_for_sort, reverse=True)
```

---

## 7. Cursor timezone-aware vs naive datetime 比較錯誤

**檔案**: `backend/app/api/accounting.py:321-333`

**問題**:
- 資料庫 `QueryHistory.created_at` 使用 `datetime.utcnow`（naive UTC）
- `fromisoformat` 解析會產生 timezone-aware datetime
- SQLAlchemy 比較會拋出 `TypeError`

**修復**:
```python
parsed = datetime.fromisoformat(cursor.replace("Z", "+00:00"))
# 如果是 timezone-aware，轉換為 UTC 後移除 tzinfo
if parsed.tzinfo is not None:
    cursor_dt = parsed.astimezone(ZoneInfo("UTC")).replace(tzinfo=None)
else:
    cursor_dt = parsed
```

---

## 8. get_daily_trend 使用伺服器時區

**檔案**: 
- `backend/app/services/user_sheets_service.py:660-692`
- `backend/app/api/accounting.py:429-432`

**問題**:
- `get_daily_trend` 使用 `datetime.now()` 計算日期範圍
- Dashboard endpoint 有用戶時區但沒傳遞

**修復**:
```python
# user_sheets_service.py - 加入 user_timezone 參數
async def get_daily_trend(
    self,
    sheet_id: str,
    days: int = 7,
    user_timezone: str = "Asia/Taipei",
) -> List[Dict]:
    tz = ZoneInfo(user_timezone)
    today = datetime.now(tz)

# accounting.py - 傳遞用戶時區
daily_trend_raw = await user_sheets_service.get_daily_trend(
    sheet_id, days=7, user_timezone=user_timezone
)
```

---

## 9. Dashboard endpoint 缺少錯誤處理

**檔案**: `backend/app/api/accounting.py:417-445`

**問題**:
- `get_recent_records()` 和 `get_daily_trend()` 沒有 try-except 保護
- 如果呼叫失敗，變數不會被初始化，導致 `NameError`

**修復**:
```python
recent_records = []  # 預設空陣列
try:
    recent_records_raw = await user_sheets_service.get_recent_records(...)
    recent_records = [...]
except Exception as e:
    logger.warning(f"Failed to get recent records for dashboard: {e}")

daily_trend = []  # 預設空陣列
try:
    daily_trend_raw = await user_sheets_service.get_daily_trend(...)
    daily_trend = [...]
except Exception as e:
    logger.warning(f"Failed to get daily trend for dashboard: {e}")
```

---

## 10. toLocaleDateString 不支援時間格式化

**檔案**: `frontend/src/components/dashboard/RecentEntriesList.tsx:28-34`

**問題**:
- `toLocaleDateString()` 不支援 `hour` 和 `minute` 選項
- 時間選項會被靜默忽略，只顯示日期

**修復**:
```tsx
// 修復前
return date.toLocaleDateString('zh-TW', {
  month: 'numeric',
  day: 'numeric',
  hour: '2-digit',    // 被忽略
  minute: '2-digit',  // 被忽略
});

// 修復後
return date.toLocaleString('zh-TW', {
  month: 'numeric',
  day: 'numeric',
  hour: '2-digit',
  minute: '2-digit',
});
```

---

## 11. 多月份日期範圍計算使用固定 30 天

**檔案**: `backend/app/api/accounting.py:259-270`

**問題**:
- 使用 `timedelta(days=30 * i)` 假設每月 30 天
- 在月份邊界可能導致重複月份或跳過月份

**範例**（假設今天是 2026-03-31）:
```
i=0: 2026-03-31 - 0 days  → "2026-03"
i=1: 2026-03-31 - 30 days → "2026-03" (重複!)
i=2: 2026-03-31 - 60 days → "2026-01" (跳過 02!)
```

**修復**:
```python
current_year = now_in_user_tz.year
current_month = now_in_user_tz.month
for i in range(3):
    target_month = current_month - i
    target_year = current_year
    while target_month <= 0:
        target_month += 12
        target_year -= 1
    months.append(f"{target_year:04d}-{target_month:02d}")
```

---

## 12. 日期範圍計算取得 8 天而非 7 天

**檔案**: `backend/app/api/accounting.py:250`

**問題**:
- 使用 `timedelta(days=7)` 計算「最近 7 天」
- 實際結果是 8 天（今天 + 前 7 天）
- 與 `get_daily_trend` 使用 `days - 1` 的邏輯不一致

**修復**:
```python
# 修復前
week_ago = (now_in_user_tz - timedelta(days=7)).strftime("%Y-%m-%d")

# 修復後
week_ago = (now_in_user_tz - timedelta(days=6)).strftime("%Y-%m-%d")
```

---

## 13. get_recent_records 使用伺服器時區

**檔案**: 
- `backend/app/services/user_sheets_service.py:610-642`
- `backend/app/api/accounting.py:429-430`

**問題**:
- `get_recent_records` 使用 `datetime.now()` 計算當前/上個月
- Dashboard endpoint 有用戶時區但沒有傳遞

**修復**:
```python
# user_sheets_service.py - 加入 user_timezone 參數
async def get_recent_records(
    self,
    sheet_id: str,
    limit: int = 5,
    user_timezone: str = "Asia/Taipei",
) -> List[Dict]:
    tz = ZoneInfo(user_timezone)
    now = datetime.now(tz)
    current_month = now.strftime("%Y-%m")

# accounting.py - 傳遞用戶時區
recent_records_raw = await user_sheets_service.get_recent_records(
    sheet_id, limit=5, user_timezone=user_timezone
)
```

---

## 14. 查詢歷史分頁載入重複顯示

**檔案**: `frontend/src/pages/QueryPage.tsx:236-246`

**問題**:
- 提交查詢時使用 `Date.now()` 作為臨時 ID 樂觀更新
- 分頁載入返回的真實記錄會被追加，導致重複顯示

**修復**:
```tsx
// 修復前
setHistory((prev) => [...prev, ...response.items]);

// 修復後
setHistory((prev) => {
  const existingQueries = new Set(
    prev.map((item) => `${item.query}|${item.answer}`)
  );
  const newItems = response.items.filter(
    (item) => !existingQueries.has(`${item.query}|${item.answer}`)
  );
  return [...prev, ...newItems];
});
```

---

## 15. Cursor 分頁同秒記錄被跳過

**檔案**: 
- `backend/app/database/crud.py:502-553`
- `backend/app/api/accounting.py:330-354`

**問題**:
- `created_at` 在 SQLite 中只有秒級精度
- 使用 `created_at < cursor` 進行分頁
- 當多筆記錄在同一秒內建立時，它們有相同的 `created_at`
- 下一頁使用 `<` 比較會跳過所有相同時間戳的記錄

**範例**（假設有 3 筆記錄在同一秒建立）:
```
記錄 A: created_at=2026-01-17 10:00:00, id=1
記錄 B: created_at=2026-01-17 10:00:00, id=2
記錄 C: created_at=2026-01-17 10:00:00, id=3

第一頁返回記錄 C (limit=1)，cursor = 2026-01-17 10:00:00
第二頁查詢 created_at < 2026-01-17 10:00:00
結果：記錄 A 和 B 被跳過！
```

**修復**:

使用 `(created_at, id)` 組合作為 cursor，用 `id` 作為 tie-breaker：

```python
# 新的 cursor 格式: "timestamp|id"
# 例如: "2026-01-17T10:00:00|3"

# crud.py - 解析並使用組合 cursor
if "|" in str(cursor):
    cursor_time_str, cursor_id_str = str(cursor).rsplit("|", 1)
    cursor_time = datetime.fromisoformat(cursor_time_str)
    cursor_id = int(cursor_id_str)
    # 使用 OR 條件避免同秒記錄被跳過
    stmt = stmt.where(
        or_(
            QueryHistory.created_at < cursor_time,
            and_(
                QueryHistory.created_at == cursor_time,
                QueryHistory.id < cursor_id,
            ),
        )
    )

# 排序也要包含 id
stmt = stmt.order_by(
    QueryHistory.created_at.desc(), QueryHistory.id.desc()
)

# 下一頁游標使用新格式
next_cursor = f"{next_record.created_at.isoformat()}|{next_record.id}"
```

**向後相容**:
- 支援舊格式純時間戳（自動降級為原本的 `<` 比較）
- 新請求會收到新格式的 cursor

---

## 相關 Commits

| Commit | 說明 |
|--------|------|
| `91b4ce2` | Enhance recent records retrieval to support user timezones |
| `66adffb` | Fix date range calculation for recent records |
| `f76ebbc` | Refactor date calculation for accurate multi-month statistics |
| `1d3149d` | Update RecentEntriesList to include time formatting |
| `b77177e` | Improve error handling in get_dashboard_summary |
| `cf0dc73` | Enhance accounting API to support user timezones |
| `f4f5655` | Improve user record sorting for accurate time-based ordering |
| `ee54151` | Refactor BudgetProgressBar to remove optional chaining |
| `a47bf6b` | Enhance accounting API for timezone support |
| `ab0e342` | Refactor budget handling in accounting and dashboard |
| `48f2ec5` | Fix pagination logic and improve budget progress display |
